


protected boolean processPacket(EmulatorThreadState thread, Packet pnew, int tidEmu) {
		
		// System.out.println("&processPacket " + (++numProcessPackets) + " : " + pnew.ip);
		
		boolean isSpaceInPipelineBuffer = true;
		
		int tidApp = javaTid * EMUTHREADS + tidEmu;
		
		sum += pnew.value;
		
		if (pnew.value == TIMER) {//leaving timer packetList now
			//resumeSleep(IpcBase.glTable.tryResumeOnWaitingPipelines(tidApp, pnew.ip)); 
			return isSpaceInPipelineBuffer;
		}
		
		if (pnew.value>SYNCHSTART && pnew.value<SYNCHEND) { //for barrier enter and barrier exit
			ResumeSleep ret = IpcBase.glTable.update(pnew.tgt, tidApp, pnew.ip, pnew.value);
			if(ret!=null){
				resumeSleep(ret);
			}
			checkForBlockingPacket(pnew.value,tidApp);
			if(threadBlockState[tidApp].getState()==blockState.BLOCK)
			{
				checkForUnBlockingPacket(pnew.value,tidApp);
				
			}
			return isSpaceInPipelineBuffer;
		}
		
		if(pnew.value == BARRIERINIT)  //for barrier initialization
		{
		
//			System.out.println("Packet is " + pnew.toString());
			BarrierTable.barrierListAdd(pnew);
			return isSpaceInPipelineBuffer;
		}
		
		if (thread.isFirstPacket) 
		{
			this.pipelineInterfaces[tidApp].getCore().currentThreads++;  //current number of threads in this pipeline
			System.out.println("num of threads on core " + tidApp + " = " + this.pipelineInterfaces[tidApp].getCore().currentThreads);
			this.pipelineInterfaces[tidApp].getCore().getExecEngine().setExecutionComplete(false);
			this.pipelineInterfaces[tidApp].getCore().getExecEngine().setExecutionBegun(true);
			currentEMUTHREADS ++;
			if(tidApp>=maxCoreAssign)
				maxCoreAssign = tidApp+1;
			
			//thread.pold.set(pnew);
			thread.packetList.add(pnew);
			liveJavaThreads++;
			threadBlockState[tidApp].gotLive();
			thread.isFirstPacket=false;
			return isSpaceInPipelineBuffer;
			
		}
		
		if (pnew.value!=INSTRUCTION && !(pnew.value>6 && pnew.value<26) && pnew.value!=Encoding.ASSEMBLY ) {
			// just append the packet to outstanding packetList for current instruction pointer
			thread.packetList.add(pnew);
		} else {
			//(numInstructions[tidEmu])++;
			//this.dynamicInstructionBuffer[tidEmu].configurePackets(thread.packets);
			
			int oldLength = inputToPipeline[tidEmu].size();
			
			long numHandledInsn = 0;
			int numMicroOpsBefore = thread.outstandingMicroOps.size();
			
			ObjParser.fuseInstruction(tidApp, thread.packetList.get(0).ip, 
				thread.packetList, thread.outstandingMicroOps);
			
			// Increment number of CISC instructions
			Statistics.setNumCISCInsn(Statistics.getNumCISCInsn(javaTid, tidEmu) + 1, javaTid, tidEmu);
			
			int numMicroOpsAfter = thread.outstandingMicroOps.size();
			if(numMicroOpsAfter>numMicroOpsBefore) {
				numHandledInsn = 1;
			} else {
				numHandledInsn = 0;
			}

			// For one CISC instruction, we generate x micro-operations. 
			// We set the CISC ip of the first micro-op to the original CISC ip.
			// IP of all the remaining micro-ops is set to -1(Invalid).
			// This ensures that we do not artificially increase the hit-rate of instruction cache.
			for(int i=numMicroOpsBefore; i<numMicroOpsAfter; i++) {
				if(i==numMicroOpsBefore) {
					thread.outstandingMicroOps.peek(i).setCISCProgramCounter(thread.packetList.get(0).ip);
				} else {
					thread.outstandingMicroOps.peek(i).setCISCProgramCounter(-1);
				}
			}
			
			// If I am running multiple benchmarks, the addresses of all the benchmarks must 
			// be tagged with benchmark ID. The tagging happens only if : 
			// (a) there are multiple benchmarks (b) the benchmark id for this thread is not zero  
			if(Main.benchmarkThreadMapping.getNumBenchmarks()>1 && tidApp>0 && Main.benchmarkThreadMapping.getBenchmarkIDForThread(tidApp)!=0) {
				for(int i=numMicroOpsBefore; i<numMicroOpsAfter; i++) {
					thread.outstandingMicroOps.peek(i).changeAddressesForBenchmark(Main.benchmarkThreadMapping.getBenchmarkIDForThread(tidApp));
				}
			}
			
			//
			if(numHandledInsn==0 && printUnHandledInsn) {
				calculateCulpritCISCInsns(thread.packetList.get(0).ip);
			}
			
			// Either add all outstanding micro-ops or none.
			if(thread.outstandingMicroOps.size()<this.inputToPipeline[tidEmu].spaceLeft()) {
				// add outstanding micro-operations to input to pipeline
				while(thread.outstandingMicroOps.isEmpty() == false) {
					this.inputToPipeline[tidEmu].enqueue(thread.outstandingMicroOps.dequeue());
				}
			} else {
				isSpaceInPipelineBuffer = false;
			}
									
			Statistics.setNumHandledCISCInsn(
				Statistics.getNumHandledCISCInsn(javaTid, tidEmu) + numHandledInsn,
				javaTid, tidEmu);
			
			int newLength = inputToPipeline[tidEmu].size();
			noOfMicroOps[tidEmu] += newLength - oldLength;
			
			if (!thread.halted && this.inputToPipeline[tidEmu].size() > INSTRUCTION_THRESHOLD) {
				thread.halted = true;
			}	

			thread.packetList.clear();
			thread.packetList.add(pnew);
		}
		
		return isSpaceInPipelineBuffer;
	}
































